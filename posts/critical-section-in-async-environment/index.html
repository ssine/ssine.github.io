<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="zh-cn"><meta name=author content="Sine"><meta name=description content="最近在写刷题群里的打卡 bot 时遇到了一个比较有意思的问题，因此来聊一下。 在一段打卡对话完成之后，程序需要把数据写入文件，这时会调用 NodeJS 的 API （Jav"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="异步环境下的代码临界区"><meta name=twitter:description content="最近在写刷题群里的打卡 bot 时遇到了一个比较有意思的问题，因此来聊一下。 在一段打卡对话完成之后，程序需要把数据写入文件，这时会调用 NodeJS 的 API （Jav"><meta property="og:title" content="异步环境下的代码临界区"><meta property="og:description" content="最近在写刷题群里的打卡 bot 时遇到了一个比较有意思的问题，因此来聊一下。 在一段打卡对话完成之后，程序需要把数据写入文件，这时会调用 NodeJS 的 API （Jav"><meta property="og:type" content="article"><meta property="og:url" content="https://ssine.ink/posts/critical-section-in-async-environment/"><meta property="article:published_time" content="2020-06-26T21:42:42+08:00"><meta property="article:modified_time" content="2020-06-26T21:42:42+08:00"><title>异步环境下的代码临界区 · Sine's Site</title><link rel=canonical href=https://ssine.ink/posts/critical-section-in-async-environment/><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=preload href="https://ssine.ink/fonts/forkawesome-webfont.woff2?v=1.1.7" as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://ssine.ink/css/coder.min.a050bb9724f6a498b574acf612d6d523bc68756ddc62579923710a8542947c52.css integrity="sha256-oFC7lyT2pJi1dKz2EtbVI7xodW3cYleZI3EKhUKUfFI=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://ssine.ink/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=https://ssine.ink/favicon.ico sizes=32x32><link rel=icon type=image/png href=https://ssine.ink/favicon.ico sizes=16x16><link rel=apple-touch-icon href=https://ssine.ink/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://ssine.ink/images/apple-touch-icon.png><meta name=generator content="Hugo 0.74.1"></head><body class=colorscheme-auto><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://ssine.ink/>Sine's Site</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://ssine.ink/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=https://kiwi.ssine.cc>维基</a></li><li class=navigation-item><a class=navigation-link href=https://ssine.ink/gallery>画廊</a></li><li class=navigation-item><a class=navigation-link href=https://ssine.ink/projects/>项目</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=https://ssine.ink/en/posts/critical-section-in-async-environment/>English</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title>异步环境下的代码临界区</h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2020-06-26T21:42:42+08:00>June 26, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>阅读时间：2 分钟</span></div></div></header><div><p>最近在写刷题群里的打卡 bot 时遇到了一个比较有意思的问题，因此来聊一下。</p><p>在一段打卡对话完成之后，程序需要把数据写入文件，这时会调用 NodeJS 的 API （JavaScript）:</p><pre><code class=language-javasctipt data-lang=javasctipt>class XXX {
  async saveData() {
    await fs.promises.writeFile(...)
    return
  }
}
</code></pre><p>由于程序是异步的，并且允许两个人同时打卡，结果导致有一次两个人的打卡对话同时结束，两个对话函数同时执行了 <code>await saveData()</code> 。</p><p>这样的后果是，第一个 <code>writeFile</code> 操作正常返回了，先执行该函数的人打卡函数正常结束，而第二个 <code>writeFile</code> 操作却永远没有结束。 第二个 <code>writeFile</code> 操作是在第一个操作进行过程中被调用的，并且没有做互斥，这可能导致 NodeJS 内部的处理出现了问题，因为 <code>writeFile</code> 将由 NodeJS 负责文件句柄的创建与回收。</p><p>那么，要如何解决这个问题呢？ 这在更底层的语言中属于典型的代码关健区，我们要对访问文件资源的代码做互斥。 在 C++ 中，互斥是通过信号量实现的，第一个访问资源的线程加锁，后面访问的线程只能等待，而这个等待的过程是阻塞的，等待时该线程被挂起。 然而在 JavaScript 环境中， Node 提供的多数 API 是非阻塞的，我们不能也不应当通过调用阻塞写文件函数的方式来解决这个问题。</p><p>异步特性使得 <code>saveData</code> 函数在任意时刻都有可能被调用，同样有可能在上一次 <code>saveData</code> 返回之前被调用。 为了实现 <code>saveData</code> 内部的代码的互斥，我们可以使用队列来记录下所有的 <code>saveData</code> 调用（也就是标志函数返回的 Promise 对象），在每次调用时，先检查队列中是否有上一次未完成的调用，如果有，就等待上一次的函数执行完再继续执行关键区逻辑，同时在执行之前将自己要返回的 Promise 对象放入队列，并在执行结束后把自己的 Promise 对象从队列中移除。 实现代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>queue</span> <span style=color:#f92672>=</span> []

<span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>serialized_async_function</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promise</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Promise(<span style=color:#a6e22e>async</span> (<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
      <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]

    <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>promises</span>.<span style=color:#a6e22e>writeFile</span>(...) <span style=color:#75715e>// any critical section logic
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>resolve</span>()
    <span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>splice</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)
  })
  <span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>promise</span>)
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promise</span>
}
</code></pre></div><p>多亏了 ES6 的 promise 对象，它使得对这一问题的解决方案得到了极大的简化。</p></div><footer></footer></article><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};</script></section></div><footer class=footer><section class=container><p>© 2016 - 2023 正弦 | <a href=https://beian.miit.gov.cn/ target=_blank>京ICP备19051756号</a></p></section></footer></main><script src=https://ssine.ink/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-127064931-1','auto');ga('send','pageview');}</script></body></html>