<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="zh-cn"><meta name=author content="Sine"><meta name=description content="NixOps is a tool for deploying to NixOS machines in a network or the cloud. 最近尝试用 NixOps 来管理个人的服务器，整体的的感受和 Nix 生态的其它工具一样，上手比较麻烦，文档很简陋，但是跑通之后体验"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="NixOps 入门介绍"><meta name=twitter:description content="NixOps is a tool for deploying to NixOS machines in a network or the cloud. 最近尝试用 NixOps 来管理个人的服务器，整体的的感受和 Nix 生态的其它工具一样，上手比较麻烦，文档很简陋，但是跑通之后体验"><meta property="og:title" content="NixOps 入门介绍"><meta property="og:description" content="NixOps is a tool for deploying to NixOS machines in a network or the cloud. 最近尝试用 NixOps 来管理个人的服务器，整体的的感受和 Nix 生态的其它工具一样，上手比较麻烦，文档很简陋，但是跑通之后体验"><meta property="og:type" content="article"><meta property="og:url" content="https://ssine.ink/posts/intro-to-nixops/"><meta property="article:published_time" content="2022-07-10T04:24:17+08:00"><meta property="article:modified_time" content="2022-07-10T04:24:17+08:00"><title>NixOps 入门介绍 · Sine's Site</title><link rel=canonical href=https://ssine.ink/posts/intro-to-nixops/><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=preload href="https://ssine.ink/fonts/forkawesome-webfont.woff2?v=1.1.7" as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://ssine.ink/css/coder.min.a050bb9724f6a498b574acf612d6d523bc68756ddc62579923710a8542947c52.css integrity="sha256-oFC7lyT2pJi1dKz2EtbVI7xodW3cYleZI3EKhUKUfFI=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://ssine.ink/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=https://ssine.ink/favicon.ico sizes=32x32><link rel=icon type=image/png href=https://ssine.ink/favicon.ico sizes=16x16><link rel=apple-touch-icon href=https://ssine.ink/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://ssine.ink/images/apple-touch-icon.png><meta name=generator content="Hugo 0.74.1"></head><body class=colorscheme-auto><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://ssine.ink/>Sine's Site</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://ssine.ink/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=https://kiwi.ssine.cc>维基</a></li><li class=navigation-item><a class=navigation-link href=https://ssine.ink/gallery>画廊</a></li><li class=navigation-item><a class=navigation-link href=https://ssine.ink/projects/>项目</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=https://ssine.ink/en/>English</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title>NixOps 入门介绍</h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2022-07-10T04:24:17+08:00>July 10, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>阅读时间：6 分钟</span></div></div></header><div><p>NixOps is a tool for deploying to NixOS machines in a network or the cloud.</p><p>最近尝试用 NixOps 来管理个人的服务器，整体的的感受和 Nix 生态的其它工具一样，上手比较麻烦，文档很简陋，但是跑通之后体验很好。</p><p>下面记录一下从头开始配置一个受 NixOps 控制的服务器的流程。</p><h1 id=创建-nixos-虚拟机>创建 NixOS 虚拟机</h1><p>首先在 VMWare ESXi 上面创建一个 NixOS 系统的虚拟机，如果使用 minimal 镜像的话需要第一次启动进 livecd 环境之后手动分区安装（参考 <a href=https://nixos.org/manual/nixos/stable/index.html#sec-installation>NixOS Manual</a> ）；或者用带 gui 的镜像，它们是支持图形化安装向导的，可以选择不安装桌面环境。 建议用后一种方式。</p><p>还有一点需要注意，目前的 NixOS 镜像不支持 UEFI secure boot （ <a href=https://github.com/NixOS/nixpkgs/issues/42127>相关 issue</a> ），因此只能以 BIOS 或者关闭 secure boot 的 UEFI 模式引导。</p><p>在公有云上使用 NixOS 可以参考 <a href=https://nixos.wiki/wiki/NixOS_friendly_hosters>NixOS friendly hosters</a> 。</p><h1 id=机器初始配置>机器初始配置</h1><p>使用 NixOps 管理服务器的前提是本地能够以 root 身份 ssh 连接到对应的机器，因此需要先在服务器上配置好 sshd ，步骤：</p><ol><li>切换为 root 用户</li><li><code>nano /etc/nixos/configuration.nix</code> 去掉 <code>services.openssh.enable = true;</code> 一行的注释</li><li><code>nixos-rebuild --switch</code> 使配置生效</li><li>将公钥添加到 <code>/root/.ssh/authorized_keys</code></li><li>在本地测试 <code>ssh root@host</code> 确认可以连接</li></ol><p>备注： 也可以用非 root 用户通过 NixOps 部署，不过属于不必要的麻烦。</p><h1 id=本地配置>本地配置</h1><h2 id=安装-nixops>安装 NixOps</h2><p>目前 NixOps 1 部分依赖有安全风险，尝试了开发中的 NixOps 2 一切顺利，建议安装 NixOps 2 ，它在 nixpkgs 中的包名是 <code>nixops_unstable</code> 。 NixOps 相关的资料并不多，几个重要的来源：</p><ul><li><code>nixops -h</code></li><li><a href=https://nixops.readthedocs.io/en/latest/index.html>NixOps 2 文档</a> / <code>man nixops</code></li><li><a href=https://github.com/NixOS/nixops>代码仓库</a></li></ul><h2 id=nixops-with-flakes>NixOps with Flakes</h2><p>安装完毕后就可以通过 <code>nixops</code> 命令来执行相关的操作了。 NixOps 首先会寻找对应的配置文件来确定执行操作的目标，查找的路径是当前目录下的 <code>flake.nix</code> 或者 <code>nixops.nix</code> ，明确指定配置文件的能力在 <a href=https://github.com/NixOS/nixops/pull/1480>2.0 的计划中</a>。 下面以使用 flake 文件的情况为例说明。</p><p>NixOps 使用 flake 输出的 <code>nixopsConfigurations</code> 属性。 一个样例 <code>flake.nix</code> 文件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{
  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;An example NixOps configuration&#34;</span>;

  inputs <span style=color:#f92672>=</span> {
    nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:nixos/nixpkgs/nixos-22.05&#34;</span>;
    home-manager <span style=color:#f92672>=</span> {
      url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:nix-community/home-manager/release-22.05&#34;</span>;
      inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>follows <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
    };
  };

  outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }<span style=color:#f92672>@</span>inputs: {
    nixopsConfigurations<span style=color:#f92672>.</span>default <span style=color:#f92672>=</span> {
      <span style=color:#66d9ef>inherit</span> nixpkgs;
      network <span style=color:#f92672>=</span> {
        description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;personal environment&#34;</span>;
        storage<span style=color:#f92672>.</span>memory <span style=color:#f92672>=</span> { };
      };
      homeserver <span style=color:#f92672>=</span> <span style=color:#f92672>import</span> <span style=color:#e6db74>./hosts/server/configuration.nix</span> inputs;
    };
  };
}
</code></pre></div><p><code>nixopsConfigurations.default</code> 有两个必备属性： <code>nixpkgs</code> 和 <code>network.storage</code> 。 前者无需赘述，后者指定了 NixOps 存储状态的位置， legacy 表示在 <code>~/.nixops/</code> 下存储相关的配置文件和 sqlite 数据库， memory 表示没有特殊状态需要存储。 nixops 在第一次连接某个机器的时候会自动生成一个 SSH 密钥对，这在管理大规模集群的时候非常方便，但是需要 legacy 类型来提供密钥存储等能力。 对于服务器比较少的场景，确保本机能够 ssh 到对应服务器并关闭自动生成功能，使用 memory 存储带来的心智负担更少。</p><p>之后就是每台机器的名字到配置的键值对。 这里的配置是原本的 <a href=https://nixos.org/manual/nixos/stable/#sec-configuration-syntax>NixOS 配置</a> 外加一些 NixOps 特定的配置属性。 前面完成服务器上的 NixOS 安装之后，我们需要把服务器上的配置文件复制到本地的 flake 仓库中，这包括了 <code>/etc/nixos/configuration.nix</code> 和 <code>/etc/nixos/hardware-configuration.nix</code> ，并在 <code>flake.nix</code> 里 import ，这一步在上面的样例中有体现。 下面是一个样例 <code>configuration.nix</code> 文件，在原本的 NixOS 配置的基础上添加了 flake 参数传入（以 home-manager 为例）和 NixOps 相关配置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{ home-manager<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }<span style=color:#f92672>@</span>inputs:
{ config<span style=color:#f92672>,</span> pkgs<span style=color:#f92672>,</span> modulesPath<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }:
{
  <span style=color:#75715e># nixops machine property</span>
  deployment <span style=color:#f92672>=</span> {
    targetHost <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;192.168.2.143&#34;</span>;
    name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;homeserver&#34;</span>;
    uuid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;6edf29a9-f665-401a-9786-7fa3eca9986a&#34;</span>;
    provisionSSHKey <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
  };

  imports <span style=color:#f92672>=</span>
    [
      <span style=color:#75715e># Include the results of the hardware scan.</span>
      <span style=color:#e6db74>./hardware-configuration.nix</span>
      home-manager<span style=color:#f92672>.</span>nixosModules<span style=color:#f92672>.</span>home-manager
    ];

  virtualisation <span style=color:#f92672>=</span> {
    <span style=color:#f92672>...</span>
</code></pre></div><p>如果没有提供 <code>deployment.uuid</code> ，在第一次部署时会自动生成并依照 storage 配置存储，也可以手动指定。 <code>deployment.provisionSSHKey</code> 默认为 true ，即默认为每个新机器提供 ssh 密钥对，这里我们不使用存储而是用本机的 ssh 直连，因此设置为 false 。</p><p>一切配置完成后，就可以执行 <code>nixops deploy</code> 来把当前的配置部署到远程机器了。 可以通过 <code>nixops list</code> 和 <code>nixops info</code> 查看当前的状态，更多指令参考上文的相关资料。</p><h1 id=一些服务配置>一些服务配置</h1><p>下面结合我个人的一些使用场景介绍各种类型的服务部署方式。 下面的内容与 NixOps 无关，主要是通过 NixOS 配置文件来完成各种服务的部署，因为目的相同所以放在这里。</p><h2 id=oci-容器>OCI 容器</h2><p>首先是 Docker 镜像。 在使用 Nix 之前可以通过 bash 脚本或者 docker-compose 声明文件记录对应的配置，并通过 <code>restart=unless-stopped</code> 确保服务一直运行，但是这种方式下服务的启动和维护仍然需要手动执行对应的脚本来完成。 通过 NixOS 我们可以实现声明式的描述 OCI 容器的配置以及自动部署，一个样例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>  virtualisation <span style=color:#960050;background-color:#1e0010>=</span> {
    docker<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
    oci-containers <span style=color:#f92672>=</span> {
      backend <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;docker&#34;</span>;
      containers <span style=color:#f92672>=</span> {
        postgres <span style=color:#f92672>=</span> {
          autoStart <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
          image <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;postgres:14&#34;</span>;
          ports <span style=color:#f92672>=</span> [ <span style=color:#e6db74>&#34;2345:5432&#34;</span> ];
          volumes <span style=color:#f92672>=</span> [ <span style=color:#e6db74>&#34;/home/sine/data:/var/lib/postgresql/data&#34;</span> ];
          environment <span style=color:#f92672>=</span> {
            POSTGRES_DB <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;db&#34;</span>;
            POSTGRES_USER <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;user&#34;</span>;
            POSTGRES_PASSWORD <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pw&#34;</span>;
          };
        };
      };
    };
  };
</code></pre></div><h2 id=systemd-服务>Systemd 服务</h2><p>有些服务用 Docker 打包会过于繁琐，或者有一些详细的配置 Docker 无法满足，这时可以借助 systemd 来为我们做服务进程的管理。 相比于直接手写 systemd 服务配置文件的方式， nix 可以更好的组织所有的服务配置，同时管理相关的依赖。 以一个服务为例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>  systemd<span style=color:#f92672>.</span>services<span style=color:#f92672>.</span>fava <span style=color:#960050;background-color:#1e0010>=</span> {
    enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
    description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;the web ui for beancount&#34;</span>;
    serviceConfig <span style=color:#f92672>=</span> {
      WorkingDirectory <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/home/sine/code/neon&#34;</span>;
      ExecStart <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>pkgs<span style=color:#f92672>.</span>nix<span style=color:#e6db74>}</span><span style=color:#e6db74>/bin/nix develop -c fava beans/base.bean -H 0.0.0.0 -p 2025&#34;</span>;
      User <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;sine&#34;</span>;
    };
    wantedBy <span style=color:#f92672>=</span> [ <span style=color:#e6db74>&#34;multi-user.target&#34;</span> ];
    path <span style=color:#f92672>=</span> [
      pkgs<span style=color:#f92672>.</span>git
    ];
  };
</code></pre></div><p><code>systemd.services</code> 由服务名到服务配置的映射组成。 其中的 <code>serviceConfig</code> 和 <code>wantedBy</code> 对应于 systemd 配置文件的相关字段，这里不再展开。 我们指定了以用户身份进入项目文件夹，入口命令 <code>nix develop -c</code> 会以工作目录下的 <code>flake.nix</code> 配置声明的环境（其中包含了<code>fava</code>）执行指令 <code>fava beans/base.bean -H 0.0.0.0 -p 2025</code> ，启动该服务。 <code>${pkgs.nix}</code> 会被替换为 nix 包的实际绝对路径。 由于 <code>nix</code> 命令实际执行时还需要调用 <code>git</code> ， <code>git</code> 也作为一个依赖添加进 <code>path</code> 配置项中。</p><p>部署完成后，可以在服务器上通过 <code>systemctl status fava</code> 来查看服务状态，以及通过 <code>journalctl -u fava</code> 查看相关的日志。</p><h2 id=本地仓库打包上传>本地仓库打包上传</h2><p>上一节的 systemd 服务实际运行时还依赖对应的仓库文件，这需要在服务启动之前在服务器上准备好。 我们可以把对应的仓库作为一个包一起部署到服务器上，进一步增加自动化的程度。</p><p>第一步是给要部署的项目打包，我这里的项目只涉及动态语言，因此可以直接源码发布。 给 <code>flake.nix</code> 的输出部分添加如下属性：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>legacyPackages<span style=color:#f92672>.</span>neon <span style=color:#960050;background-color:#1e0010>=</span> pkgs<span style=color:#f92672>.</span>stdenv<span style=color:#f92672>.</span>mkDerivation {
  name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;neon&#34;</span>;
  src <span style=color:#f92672>=</span> self;
  buildPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34; &#34;</span>; <span style=color:#75715e># prevent default make command and do nothing</span>
  installPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;cp -r . $out&#34;</span>;
};
</code></pre></div><p>之后执行 <code>nix build .#neon</code> ，确定输出文件夹中的内容是当前项目的源码。 需要注意的一点是这里不能使用 flake 的 <code>outputs.packages</code> 属性，因为这种情况下的包不允许引用其他包（<code>src = self;</code>），因此只能声明在 <code>outputs.legacyPackages</code> 。 <a href=https://discourse.nixos.org/t/flake-questions/8741>相关讨论</a> 。</p><p>第二步是把当前包添加为 NixOS 配置的依赖。 首先是在 <code>flake.nix</code> 文件中添加仓库为输入源，写法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>neon <span style=color:#960050;background-color:#1e0010>=</span> {
  url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;git+ssh://git@github.com/username/repo&#34;</span>;
  inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>follows <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
};
</code></pre></div><p>由于 <code>nixops deploy</code> 无法更新 <code>flake.lock</code> 文件，如果有新的 input 会报错。 我们需要手动更新单个依赖版本 <code>nix flake lock --update-input neon</code> 。</p><p>但是更新的时候失败了，原因是 Nix 目前不支持私有仓库使用 Git LFS ， <a href=https://github.com/NixOS/nix/issues/4623>相关 issue</a> 。 如果没有使用 LFS 可以继续，这里我们改为使用本地目录：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>neon <span style=color:#960050;background-color:#1e0010>=</span> {
  url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;git+file:///home/path/to/repo&#34;</span>;
  inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>follows <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
};
</code></pre></div><p>之后更新依赖，成功。 下一步就是在相关的地方使用我们的依赖了。 以上面的 fava 服务为例，我们需要这个项目的根文件夹作为工作目录 <code>WorkingDirectory = "/home/sine/code/neon";</code> ，之前是手动把这个仓库 clone 到对应的本地目录的，现在，我们可以直接把它指定为 <code>WorkingDirectory = inputs.neon.legacyPackages.x86_64-linux.neon;</code> ，省去了每次更新仓库的麻烦。</p><p>同时，我们也可以把这个包的目录链接到想要的位置来方便访问。 例如当前用户的家目录：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>home-manager <span style=color:#960050;background-color:#1e0010>=</span> {
  users<span style=color:#f92672>.</span>sine <span style=color:#f92672>=</span> {
    home<span style=color:#f92672>.</span>file<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;secret-folder/neon&#34;</span><span style=color:#f92672>.</span>source <span style=color:#f92672>=</span> inputs<span style=color:#f92672>.</span>neon<span style=color:#f92672>.</span>legacyPackages<span style=color:#f92672>.</span>x86_64-linux<span style=color:#f92672>.</span>neon;
  };
};
</code></pre></div><p>或者 <code>/etc</code> 下面：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>environment<span style=color:#f92672>.</span>etc<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;secret-folder/neon&#34;</span><span style=color:#f92672>.</span>source <span style=color:#960050;background-color:#1e0010>=</span> inputs<span style=color:#f92672>.</span>neon<span style=color:#f92672>.</span>legacyPackages<span style=color:#f92672>.</span>x86_64-linux<span style=color:#f92672>.</span>neon;
</code></pre></div><h1 id=总结>总结</h1><p>目前基于 OCI 容器的部署方案和相关的生态系统已经很成熟了， NixOps 在这方面无法与之相比。 但是 NixOps 有一些独特的侧重点，很好的解决了一些 K8S 等工具无力触及的问题：</p><p><strong>对机器底层状态的管理</strong>， NixOps 的配置是基于 NixOS 配置文件的，能够很好的描述机器级别的状态，例如硬盘挂载、网络配置、用户权限。 相比之下， K8S 只是在机器上安装的一个软件，没有办法对自己所在节点的状态做管理。</p><p><strong>对软件的详细配置</strong>， 同样是借助于整个 Nix 生态，我们可以通过 NixOS 以及 home-manager 等工具对运行在机器上的软件做很详细的配置，比如服务器上用户的 git name 和 email 。 一些服务也可以不经过 docker 虚拟化就能在服务器上可靠的分发和运行，这给了我们比 docker 镜像更细粒度的软件配置能力。</p><p>综上所述，裸金属层面的集群管理，不需要或者不方便用 Docker 分发的小服务或者状态的管理是 NixOps 比较典型的使用场景。 NixOps 的配置文件是按照机器划分的，关注对每一台机器的配置，而 K8S 的配置是按照服务划分的，关注一个服务的可用性。 我们可以以此为根据判断使用哪一种工具。</p><hr><p>最后还有一个悬而未决的问题，在 <code>configuration.nix</code> 中指定的 TUNA 镜像源 <code>nix.settings.substituters = [ "https://mirrors.tuna.tsinghua.edu.cn/nix-channels/store" ];</code> 看起来 NixOps 在服务器上安装包的时候并没有生效，但是服务器上的 Nix 命令有使用 TUNA 源，应该和<a href=https://github.com/NixOS/nixops/blob/master/nixops/backends/__init__.py#L631>源码中这里</a>的指令配置有关，没有进一步调查。</p></div><footer></footer></article><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};</script></section></div><footer class=footer><section class=container><p>© 2016 - 2023 正弦 | <a href=https://beian.miit.gov.cn/ target=_blank>京ICP备19051756号</a></p></section></footer></main><script src=https://ssine.ink/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-127064931-1','auto');ga('send','pageview');}</script></body></html>