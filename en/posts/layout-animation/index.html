<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=author content="Sine"><meta name=description content="Note: This article is automatically translated, please turn to the Chinese version for more accurate expression if possible.
When I was developing Kiwi recently, I encountered some problems with the front-end layout animation. It is quite interesting to study it in depth. The following two points are related to the animation transition when the layout changes.
The first is when an item displayed in the content bar changes, just put the new item to the end when adding, but if the previous item is removed, the item below will slide up, as shown in the following figure:"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Layout Animation: FLIP and Reparenting"><meta name=twitter:description content="Note: This article is automatically translated, please turn to the Chinese version for more accurate expression if possible.
When I was developing Kiwi recently, I encountered some problems with the front-end layout animation. It is quite interesting to study it in depth. The following two points are related to the animation transition when the layout changes.
The first is when an item displayed in the content bar changes, just put the new item to the end when adding, but if the previous item is removed, the item below will slide up, as shown in the following figure:"><meta property="og:title" content="Layout Animation: FLIP and Reparenting"><meta property="og:description" content="Note: This article is automatically translated, please turn to the Chinese version for more accurate expression if possible.
When I was developing Kiwi recently, I encountered some problems with the front-end layout animation. It is quite interesting to study it in depth. The following two points are related to the animation transition when the layout changes.
The first is when an item displayed in the content bar changes, just put the new item to the end when adding, but if the previous item is removed, the item below will slide up, as shown in the following figure:"><meta property="og:type" content="article"><meta property="og:url" content="https://ssine.ink/en/posts/layout-animation/"><meta property="article:published_time" content="2021-08-29T20:14:40+08:00"><meta property="article:modified_time" content="2021-08-29T20:14:40+08:00"><title>Layout Animation: FLIP and Reparenting · Sine's Site</title><link rel=canonical href=https://ssine.ink/en/posts/layout-animation/><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=preload href="https://ssine.ink/fonts/forkawesome-webfont.woff2?v=1.1.7" as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://ssine.ink/css/coder.min.a050bb9724f6a498b574acf612d6d523bc68756ddc62579923710a8542947c52.css integrity="sha256-oFC7lyT2pJi1dKz2EtbVI7xodW3cYleZI3EKhUKUfFI=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://ssine.ink/css/coder-dark.min.126ad3988d46bdae6217a11105b53c9662bca05f39d42d3c0fb366919d334620.css integrity="sha256-EmrTmI1Gva5iF6ERBbU8lmK8oF851C08D7NmkZ0zRiA=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=https://ssine.ink/favicon.ico sizes=32x32><link rel=icon type=image/png href=https://ssine.ink/favicon.ico sizes=16x16><link rel=apple-touch-icon href=https://ssine.ink/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://ssine.ink/images/apple-touch-icon.png><meta name=generator content="Hugo 0.74.1"></head><body class=colorscheme-auto><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://ssine.ink/en>Sine's Site</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://ssine.ink/en/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://kiwi.ssine.cc>Wiki</a></li><li class=navigation-item><a class=navigation-link href=https://ssine.ink/en/gallery>Gallery</a></li><li class=navigation-item><a class=navigation-link href=https://ssine.ink/en/projects/>Projects</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=https://ssine.ink/posts/layout-animation/>中文</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title>Layout Animation: FLIP and Reparenting</h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2021-08-29T20:14:40+08:00>August 29, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>7-minute read</span></div></div></header><div><p><strong>Note: This article is automatically translated, please turn to the Chinese version for more accurate expression if possible.</strong></p><p>When I was developing Kiwi recently, I encountered some problems with the front-end layout animation. It is quite interesting to study it in depth. The following two points are related to the animation transition when the layout changes.</p><p>The first is when an item displayed in the content bar changes, just put the new item to the end when adding, but if the previous item is removed, the item below will slide up, as shown in the following figure:</p><image src=./flip.gif style="margin: 0 auto;display: block;"><p>How can this effect be achieved? The most straightforward way is to traverse all the items below it every time an item is deleted, and add an animation to them, moving from the bottom to the top where they should go. But this operation is very inelegant, crosses the boundary of the component, and brings additional complexity. So is it possible to use a simpler way to make a component automatically start the animation to transition to a new position when its position changes?</p><h1 id=flip-operation>FLIP operation</h1><p>The difficulty with this requirement is that HTML does not provide built-in events that are triggered when an element moves. If we want to directly check whether an element has moved, we need to poll an element every once in a while and remember its previous position to determine whether its position has changed. This has two fatal disadvantages. The first is that the animation is not updated in time, and the element has moved to a new position, but suddenly flashes back to the original position and plays the animation; the second is that the performance is worrying, and everything is checked every polling interval. The position of the element.</p><p>The polling method does not work. We need to find the trigger from the source of the layout change. If JS directly manipulates the DOM, then we can check the new position when all elements may change. For example, like the two elements 1 and 2 in the above figure, assuming their position is AB, 1 is deleted, and the position of 2 is moved from A to B, then whenever an element is deleted, the elements will take the initiative Check your new position, 2 find that your position is A, which is different from the last position B, then play an animation to change your position from B to A, that is, the CSS transition property changes from $-(AB )$ to $0$.</p><p>This technique is called FLIP and it was first used in<a href=https://aerotwist.com/blog/flip-your-animations/>This blog</a>The main steps are as follows:</p><ol><li>First: the initial state of the element(s) involved in the transition.</li><li>Last: the final state of the element(s).</li><li>Invert: here’s the fun bit. You figure out from the first and last how the element has changed, so – say – its width, height, opacity. Next you apply transforms and opacity changes to reverse, or invert, them. If the element has moved 90px down between First and Last, you would apply a transform of -90px in Y. This makes the elements appear as though they’re still in the First position but, crucially, they’re not.</li><li>Play: switch on transitions for any of the properties you changed, and then remove the inversion changes. Because the element or elements are in their final position removing the transforms and opacities will ease them from their faux First position, out to the Last position.</li></ol><p>There is actually a problem here. Since the DOM has changed, we actually read the animation to the new position first and then execute the animation. Why don&rsquo;t we see the element jump to the new position first and then flash back to play the animation? This is because the location update occurs during the execution of our user script. After we delete element 1, if we try to pass<code>getBoundingClientRect</code> This type of API to get the position of element 2 will trigger a browser’s<a href=https://sites.google.com/site/getsnippet/javascript/dom/repaints-and-reflows-manipulating-the-dom-responsibly>reflow</a> , Recalculate the position of all DOM elements and return, so that rendering will not be performed until the end of our synchronization script execution. Therefore, there will be no element jumping back and forth.</p><p>How to determine whether an element is deleted in React? Use the one that is triggered synchronously at the end of the DOM operation<code>useLayoutEffect</code> Hook is enough. After all, we don&rsquo;t care how many times we check, as long as we set up the animation when the position changes.</p><h1 id=reparenting>Reparenting</h1><p>The above solution works fine under the layout of one content bar, but a new problem appears under the layout of multiple content bars (waterfall). This problem is related to React.</p><p>Let me first talk about how the multi-column layout works. The laziest implementation is naturally to put the stream with the shortest length when a new entry comes, and no other operations will be done later, but this will make the length of several streams very unbalanced after several operations of closing the entry. Therefore, every time there is an item change, the flow layout will be recalculated according to the following process:</p><ol><li>Maintain a list of open entries, push when adding entries, and splice when removing entries</li><li>Assign a list to each content stream</li><li>Traverse the list of entries, and put the current entry into the stream with the shortest length each time</li><li>Update the length of this stream</li></ol><p>When rendering, each stream corresponds to a div, which contains all the elements of the current stream.</p><image src=./reparent-1.png style="max-width: 500px;margin: 0 auto;display: block;"><p>For example, if the above picture is the content of the waterfall at a certain time, if item 6 is deleted, and the layout recalculated through the above process is as follows:</p><image src=./reparent-2.png style="max-width: 500px;margin: 0 auto;display: block;"><p>At this point, the expected animation direction is as follows:</p><image src=./reparent-3.png style="max-width: 500px;margin: 0 auto;display: block;"><p>However, it was not actually played. This is because the code structure is a React component for each stream. Inside the stream is a list of items. After we re-render, React&rsquo;s virtual DOM diff algorithm cannot identify the internal element movement process in the above figure. , So the previous item component will be destroyed and one will be reconstructed. This causes the &ldquo;previous position&rdquo; memorized in item 7 to be cleared, and the position change cannot be detected and the animation is played. This question has one in the React repository<a href=https://github.com/facebook/react/issues/13044>issue</a> It has been discussed that it will cause serious problems when creating a component is expensive or needs to remember the state. There is currently no official solution to this problem, but fortunately someone has implemented a library<a href=https://github.com/Paol-imi/react-reparenting>react-reparenting</a> To solve this problem.</p><p>Let&rsquo;s break away from this library and think about the solution. able to pass <a href=https://reactjs.org/docs/portals.html>Portal</a> To do this, render all the entries into a Portal list, and then put them into the corresponding stream, so that the Portal will only be constructed and destructed when the element is actually created and closed. But this solution is contrary to the structured design of React itself. Another solution is to manually adjust the virtual DOM node inside React before rendering to trick React into thinking that this element has not changed, and naturally it will not be re-constructed. This requires changes to the internal data structure of React, but it is a more conceptually complete implementation with minimal impact on the existing code, and it is also the implementation adopted by react-reparenting mentioned above. The downside is that it is an internal implementation. If React makes changes to this structure, it does not need to update the semver version of React. Therefore, there is a possibility that the code may stop working if only updating the minor version of React (without introducing API changes). Therefore, the best solution is for React to officially include this implementation.</p><p>What exactly do we need to do? When the code causes a component to be transferred from one parent to another parent, we have to manually tell react-reparenting to change the virtual DOM (codename<a href=https://github.com/acdlite/react-fiber-architecture>fiber</a>) Perform the corresponding transfer operation, so that it will not be noticed by the diff algorithm during the next rendering. Take the above picture as an example, that is</p><ul><li>Flow 2 / entry 7 -> flow 3 second position</li><li>Flow 3 / entry 8 -> flow 2 third position</li></ul><p>As for the deleted entry 6, it will be discovered and destroyed by the diff algorithm.</p><image src=./reparent-result.gif style="margin: 0 auto;display: block;"><p>In this way, the layout problem is completely solved.</p></div><footer></footer></article><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};</script></section></div><footer class=footer><section class=container><p>© 2016 - 2023 Sine Liu</p></section></footer></main><script src=https://ssine.ink/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-127064931-1','auto');ga('send','pageview');}</script></body></html>